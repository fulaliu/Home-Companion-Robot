<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>ROS WebSocket æ§åˆ¶ä¸å›¾åƒæ¥æ”¶</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
    .row { display: flex; gap: 8px; align-items: center; margin: 8px 0; flex-wrap: wrap; }
    input[type="text"] { width: 340px; padding: 6px 8px; }
    button { padding: 8px 12px; cursor: pointer; }
    #status { font-weight: 600; }
    #log { height: 160px; overflow: auto; border: 1px solid #ccc; padding: 8px; white-space: pre-wrap; background: #fafafa;}
    #video { width: 100%; max-width: 960px; background: #000; }
    .pad { display: grid; grid-template-columns: 60px 60px 60px; gap: 6px; }
    .pad button { height: 42px; }
    .muted { color: #666; font-size: 12px; }
  </style>
</head>
<body>
  <h2>ROS WebSocket å®¢æˆ·ç«¯ï¼ˆå›¾åƒæ¥æ”¶ + æ–¹å‘æ§åˆ¶ï¼‰</h2>

  <div class="row">
    <label for="wsUrl">WebSocket URLï¼š</label>
    <input id="wsUrl" type="text" value="ws://localhost:8765" />
    <button id="btnConnect">è¿æ¥</button>
    <button id="btnDisconnect" disabled>æ–­å¼€</button>
    <span id="status">æœªè¿æ¥</span>
  </div>

  <div class="row">
    <div class="pad">
      <span></span>
      <buttonâ†‘ ä¸Š</button>
      <span></span>

      leftâ† å·¦</button>
      <button data-action="stop"utton data-action="    <span></span>
      <button data-action="backwardpan></span>
    </div>
    <div class="muted">
      é”®ç›˜å¿«æ·é”®ï¼šâ†‘ï¼ˆforwardï¼‰ã€â†“ï¼ˆbackwardï¼‰ã€â†ï¼ˆleftï¼‰ã€â†’ï¼ˆrightï¼‰ã€ç©ºæ ¼ï¼ˆstopï¼‰
    </div>
  </div>

  <div class="row">
    <img id="video" alt="ç­‰å¾…è§†é¢‘å¸§â€¦" />
  </div>

  <div class="row">
    <div>
      <div><strong>æ—¥å¿—</strong></div>
      <div id="log"></div>
    </div>
  </div>

  <script>
    let ws = null;
    let reconnectTimer = null;
    let reconnectAttempts = 0;
    let lastObjectUrl = null;

    const wsUrlInput = document.getElementById('wsUrl');
    const btnConnect  = document.getElementById('btnConnect');
    const btnDisconnect = document.getElementById('btnDisconnect');
    const statusEl = document.getElementById('status');
    const logEl = document.getElementById('log');
    const imgEl = document.getElementById('video');

    // å…è®¸é€šè¿‡ URL å‚æ•° ?ws=ws://ip:port ç›´æ¥æ³¨å…¥
    (function initByQuery() {
      const u = new URL(location.href);
      const wsParam = u.searchParams.get('ws');
      if (wsParam) wsUrlInput.value = wsParam;
    })();

    function log(msg) {
      const ts = new Date().toLocaleTimeString();
      logEl.textContent += `[${ts}] ${msg}\n`;
      logEl.scrollTop = logEl.scrollHeight;
      console.log(msg);
    }

    function setStatus(text, color = 'black') {
      statusEl.textContent = text;
      statusEl.style.color = color;
    }

    function cleanupImageUrl() {
      if (lastObjectUrl) {
        URL.revokeObjectURL(lastObjectUrl);
        lastObjectUrl = null;
      }
    }

    function connect(url) {
      if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
        log('å·²æœ‰è¿æ¥æˆ–æ­£åœ¨è¿æ¥ä¸­ã€‚');
        return;
      }
      try {
        ws = new WebSocket(url);
      } catch (e) {
        log(`åˆ›å»º WebSocket å¤±è´¥ï¼š${e}`);
        return;
      }
      ws.binaryType = 'arraybuffer';

      ws.onopen = () => {
        setStatus('å·²è¿æ¥', 'green');
        log(`âœ… Connected: ${url}`);
        btnConnect.disabled = true;
        btnDisconnect.disabled = false;
        reconnectAttempts = 0;
        // å¯é€‰ï¼šå‘é€ä¸€æ¬¡ hello
        // ws.send('hello');
      };

      ws.onmessage = (ev) => {
        // æœåŠ¡ç«¯å¹¿æ’­çš„åº”ä¸º JPEG äºŒè¿›åˆ¶ï¼›è‹¥æ”¶åˆ°æ–‡æœ¬ï¼Œå¯æŒ‰éœ€å¤„ç†
        if (typeof ev.data === 'string') {
          log(`æ”¶åˆ°æ–‡æœ¬: ${ev.data}`);
          return;
        }
        if (ev.data instanceof ArrayBuffer) {
          const blob = new Blob([ev.data], { type: 'image/jpeg' });
          const objUrl = URL.createObjectURL(blob);
          cleanupImageUrl();
          lastObjectUrl = objUrl;
          imgEl.onload = () => {
            // å›¾ç‰‡è§£ç åå†é‡Šæ”¾ä¸Šä¸€ä¸ª URLï¼Œé¿å…èŠ±å±
            // ï¼ˆæ³¨æ„ï¼šå½“å‰ objUrl ä¸èƒ½ç«‹å³ revokeï¼Œå¦åˆ™å›¾åƒè¿˜æœªè§£ç ï¼‰
          };
          imgEl.src = objUrl;
        } else if (ev.data instanceof Blob) {
          // æŸäº›æµè§ˆå™¨å¯èƒ½ç›´æ¥å°±æ˜¯ Blob
          const objUrl = URL.createObjectURL(ev.data);
          cleanupImageUrl();
          lastObjectUrl = objUrl;
          imgEl.src = objUrl;
        }
      };

      ws.onerror = (err) => {
        log(`âŒ Socket error: ${err?.message || err}`);
      };

      ws.onclose = (ev) => {
        setStatus(`å·²æ–­å¼€ï¼ˆcode=${ev.code} reason=${ev.reason || 'n/a'}ï¼‰`, 'red');
        log(`ğŸ”Œ Disconnected. code=${ev.code} reason=${ev.reason || 'n/a'}`);
        btnConnect.disabled = false;
        btnDisconnect.disabled = true;
        cleanupImageUrl();
        imgEl.removeAttribute('src');
        scheduleReconnect(url);
      };
    }

    function scheduleReconnect(url) {
      if (reconnectTimer) return;
      // ç®€å•çš„æŒ‡æ•°é€€é¿ï¼š1s, 2s, 4s, â€¦ æœ€å¤§ 30s
      const delay = Math.min(30000, 1000 * Math.pow(2, reconnectAttempts++));
      log(`å°†åœ¨ ${Math.round(delay/1000)}s åå°è¯•é‡è¿â€¦`);
      reconnectTimer = setTimeout(() => {
        reconnectTimer = null;
        connect(url);
      }, delay);
    }

    function disconnect() {
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }
      if (ws) {
        const s = ws.readyState;
        try { ws.close(1000, 'client close'); } catch {}
        if (s === WebSocket.CLOSED) {
          setStatus('å·²æ–­å¼€', 'red');
          btnConnect.disabled = false;
          btnDisconnect.disabled = true;
        }
      }
    }

    function sendAction(action) {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        log('å°šæœªè¿æ¥ï¼Œæ— æ³•å‘é€æŒ‡ä»¤ã€‚');
        return;
      }
      const payload = { action };
      try {
        ws.send(JSON.stringify(payload));
        log(`â¡ å‘é€: ${JSON.stringify(payload)}`);
      } catch (e) {
        log(`å‘é€å¤±è´¥: ${e}`);
      }
    }

    // ç»‘å®šæŒ‰é’®
    btnConnect.addEventListener('click', () => connect(wsUrlInput.value.trim()));
    btnDisconnect.addEventListener('click', () => disconnect());

    // æ–¹å‘/åœæ­¢æŒ‰é’®
    document.querySelectorAll('button[data-action]').forEach(btn => {
      btn.addEventListener('click', () => {
        const action = btn.getAttribute('data-action');
        sendAction(action);
      });
    });

    // é”®ç›˜å¿«æ·é”®
    window.addEventListener('keydown', (ev) => {
      switch (ev.key) {
        case 'ArrowUp':    ev.preventDefault(); return sendAction('forward');
        case 'ArrowDown':  ev.preventDefault(); return sendAction('backward');
        case 'ArrowLeft':  ev.preventDefault(); return sendAction('left');
        case 'ArrowRight': ev.preventDefault(); return sendAction('right');
        case ' ':          ev.preventDefault(); return sendAction('stop');
      }
    });

    // é¡µé¢å…³é—­æ—¶æ¸…ç†
    window.addEventListener('beforeunload', () => {
      try { disconnect(); } catch {}
      cleanupImageUrl();
    });
  </script>
</body>
</html>
